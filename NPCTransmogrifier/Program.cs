using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Records;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Noggog;
using System;
using System.Drawing;

namespace NPCTransmogrifier
{
    public class Program
    {
        static Lazy<TransmogSettings> Settings = null!; // define a Settings object that will be created or passed to the program. These settings can be found in the accompanying TransmogSettings.cs file

        public static async Task<int> Main(string[] args) // starting point of the patcher that Synthesis will recognize
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch) // tells Synthesis to run the code within public static void RunPatch below
                .SetTypicalOpen(GameRelease.SkyrimSE, "NPCTransmogrifier.esp") // boilerplate code for patchers for Skyrim Special Edition
                .SetAutogeneratedSettings( // Tells Synthesis to auto-generate the settings the first time a user installs this patcher. On subsequent runs, it'll look for settings created in a "settings.json" file
                    nickname: "Settings",
                    path: "settings.json",
                    out Settings)
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state) 
        {
            var settings = Settings.Value; // Get the patcher's Settings
            var random = new Random(); // Create a random number generator
            int patchedNPCcount = 0; // Create a tracker that records how many NPCs were patched, which we can print at the end so the users knows if the patcher worked
            var coreMods = settings.ModsToPatch.Select(x => state.LoadOrder.GetIfEnabled(x));

            var npcs = coreMods.WinningOverrides<INpcGetter>().ToArray(); // Get all NPCs in the user's load order (only consider conflict winners, not any of the plugins that get overridden)

            var headPartMap = new Dictionary<HeadPart.TypeEnum, Dictionary<IFormLink<IRaceGetter>, Dictionary<MaleFemaleGender, List<IHeadPartGetter>>>>();

            foreach (HeadPart.TypeEnum type in Enum.GetValues(typeof(HeadPart.TypeEnum))) {
                headPartMap[type] = new();
            	foreach (var race in settings.RacesToPatch) {
                    headPartMap[type][race] = new();
                
            		var headParts = state.LoadOrder.PriorityOrder.HeadPart().WinningOverrides().Where(x =>
	                    x.Type == type &&
	           	        !x.ValidRaces.IsNull &&
	                    (x.Flags & HeadPart.Flag.Playable) == HeadPart.Flag.Playable &&
	                    state.LinkCache.Resolve<IFormListGetter>(x.ValidRaces.FormKey).ContainsForm(race));
	                
            		headPartMap[type][race][MaleFemaleGender.Male] = headParts.Where(x => x.Flags.HasFlag(HeadPart.Flag.Male)).ToList();
            		headPartMap[type][race][MaleFemaleGender.Female] = headParts.Where(x => x.Flags.HasFlag(HeadPart.Flag.Female)).ToList();
            	}
            }
            
            foreach (var coreNPC in npcs.Where(x => settings.RacesToPatch.Contains(x.Race))) // loop through each NPC
            {
            	if (!state.LinkCache.TryResolve<INpcGetter>(coreNPC.FormKey, out var npcGetter)) continue; //making the assumption that we haven't changed the npc's race
                var localNPC = npcGetter.DeepCopy(); // create an in-memory copy of the NPC
                var npcGender = localNPC.Configuration.Flags.HasFlag(NpcConfiguration.Flag.Female) ? MaleFemaleGender.Female : MaleFemaleGender.Male;
                var npcChanged = false;

                Console.WriteLine($"Patching {localNPC.EditorID}");

                if (settings.PatchFaceMorph)
                {
                    localNPC.FaceMorph ??= new();
                    var npcFace = localNPC.FaceMorph; // get the NPC's face morph

                    // randomize all of the sliders
                    npcFace.BrowsForwardVsBack = random.GenerateMorph();
                    npcFace.BrowsInVsOut = random.GenerateMorph();
                    npcFace.BrowsUpVsDown = random.GenerateMorph();
                    npcFace.CheeksForwardVsBack = random.GenerateMorph();
                    npcFace.CheeksUpVsDown = random.GenerateMorph();
                    npcFace.ChinNarrowVsWide = random.GenerateMorph();
                    npcFace.ChinUnderbiteVsOverbite = random.GenerateMorph();
                    npcFace.ChinUpVsDown = random.GenerateMorph();
                    npcFace.EyesForwardVsBack = random.GenerateMorph();
                    npcFace.EyesInVsOut = random.GenerateMorph();
                    npcFace.EyesUpVsDown = random.GenerateMorph();
                    npcFace.JawForwardVsBack = random.GenerateMorph();
                    npcFace.JawNarrowVsWide = random.GenerateMorph();
                    npcFace.JawUpVsDown = random.GenerateMorph();
                    npcFace.LipsInVsOut = random.GenerateMorph();
                    npcFace.LipsUpVsDown = random.GenerateMorph();
                    npcFace.NoseLongVsShort = random.GenerateMorph();
                    npcFace.NoseUpVsDown = random.GenerateMorph();

                    npcChanged = true;
                }

                if (settings.PatchHeadParts) {
                    localNPC.HeadParts.Clear();

                    // add hair
                    var hairList = headPartMap[HeadPart.TypeEnum.Hair][localNPC.Race][npcGender];
                    if (random.Next(100) < settings.HairChance && hairList.Any())
                        localNPC.HeadParts.Add(hairList[random.Next(hairList.Count)]);

                    // add eyes
                    var eyeList = headPartMap[HeadPart.TypeEnum.Eyes][localNPC.Race][npcGender];
                    if (eyeList.Any())
                        localNPC.HeadParts.Add(eyeList[random.Next(eyeList.Count)]);

                    // add eyebrows
                    var eyebrowList = headPartMap[HeadPart.TypeEnum.Eyebrows][localNPC.Race][npcGender];
                    if (random.Next(100) < settings.EyebrowChance && eyebrowList.Any())
                        localNPC.HeadParts.Add(eyebrowList[random.Next(eyebrowList.Count)]);

                    // add scars to some npcs
                    var scarList = headPartMap[HeadPart.TypeEnum.Scars][localNPC.Race][npcGender];
                    if (random.Next(100) < settings.ScarChance && scarList.Any())
                        localNPC.HeadParts.Add(scarList[random.Next(scarList.Count)]);

                    // add facial hair to some npcs
                    var facialHairList = headPartMap[HeadPart.TypeEnum.FacialHair][localNPC.Race][npcGender];
                    if (random.Next(100) < settings.FacialHairChance && facialHairList.Any())
                        localNPC.HeadParts.Add(facialHairList[random.Next(facialHairList.Count)]);

                    npcChanged = true;
                }

                if (settings.PatchFaceParts) {
                	//TODO: figure out why this doesn't work
                    localNPC.FaceParts ??= new();
                    var faceParts = localNPC.FaceParts;
                    var availableMorphs = state.LinkCache.Resolve<IRaceGetter>(localNPC.Race.FormKey)?.HeadData?[npcGender]?.AvailableMorphs ?? throw new Exception();

                    faceParts.Nose = availableMorphs.Nose?.Data.PickRandomFromSpan(random) ?? 0;
                    faceParts.Eyes = availableMorphs.Eye?.Data.PickRandomFromSpan(random) ?? 0;
                    faceParts.Mouth = availableMorphs.Lip?.Data.PickRandomFromSpan(random) ?? 0;

                    npcChanged = true;
                }

                if (settings.PatchHairColor) {
                	//TODO: actually implement this
                    var availableHairColors = state.LinkCache.Resolve<IRaceGetter>(localNPC.Race.FormKey)?.HeadData?[npcGender]?.AvailableHairColors ?? throw new Exception();
                    npcChanged = true;
                }

                if (settings.PatchTextureLighting) {
                    localNPC.TextureLighting = Color.FromArgb(
                    	(int)(((random.Next(500001) + 30000) / 1000000f) * byte.MaxValue),
                    	(int)(((random.Next(500001) + 30000) / 1000000f) * byte.MaxValue),
                    	(int)(((random.Next(500001) + 30000) / 1000000f) * byte.MaxValue)
                    );
                    
                    npcChanged = true;
                }

                if (npcChanged) {
                	patchedNPCcount++;
                	state.PatchMod.Npcs.Set(localNPC);
                }
            }

            Console.WriteLine("Transmogrifier patched {0} NPCs", patchedNPCcount); // once the patcher loops through all NPCs, write a message to the screen to show the user how many NPCs were patched. The "{0}" will be replaced by the value of patchedNPCcount.
            // That's it!
        }
    }

    internal static class Extentions {
        internal static float GenerateMorph(this Random random) // Generate a random decimal number between min and max
        {
            var morphVal = random.NextDouble() * random.NextDouble();

            if (random.NextInt64() % 2 == 0)
                morphVal *= -1;

            return (float)morphVal;
        }

        internal static bool ContainsForm<T>(this IFormListGetter formList, IFormLink<T> target) where T : class, IMajorRecordGetter {
        	foreach (var item in formList.Items)
                if (item.FormKey == target.FormKey)
                    return true;

        	return false;
        }

        internal static uint PickRandomFromSpan(this ReadOnlyMemorySlice<byte> span, Random random) {
        	List<uint> possibleVals = new();
            var bytes = new byte[4];
			
			for (int i = 0; i < 4; i++)
                bytes[i] = span[i];

            var flags = BitConverter.ToUInt32(bytes, 0);

            for (int i = 0; i < 32; i++)
                if ((flags & (1u << i)) != 0)
                    possibleVals.Add((uint)i);
        	
        	return possibleVals[random.Next(possibleVals.Count)];
        }
    }
}
